<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Image Geometrizer with Custom Brush</title>
    <style>
        body { font-family: Arial, sans-serif; }
        canvas { border: 1px solid black; display: inline-block; }
        #controls { margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Image Geometrizer with Custom Brush</h1>
    <p>Upload an image to geometrize (from Blender or elsewhere). Optionally upload a custom brush image (transparent PNG recommended for shapes like horror elements). Adjust settings and start the process.</p>
    
    <div id="controls">
        <label>Target Image: <input type="file" id="imageUpload" accept="image/*"></label><br>
        <label>Custom Brush (optional): <input type="file" id="brushUpload" accept="image/*"></label><br>
        <label>Shape Opacity (1-255): <input type="number" id="shapeOpacity" value="128" min="1" max="255"></label><br>
        <label>Candidates per Step: <input type="number" id="candidates" value="20" min="1" max="100"></label><br>
        <label>Mutations per Candidate: <input type="number" id="mutations" value="50" min="1" max="300"></label><br>
        <label>Max Shapes: <input type="number" id="maxShapes" value="3000" min="100" max="10000"></label><br>
        <button id="startBtn">Start</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Reset</button>
    </div>
    
    <canvas id="original" width="0" height="0"></canvas>
    <canvas id="geometrized" width="0" height="0"></canvas>
    
    <script>
        let targetImg = null;
        let targetImageData = null;
        let brushImg = null;
        let currentCtx = null;
        let width = 0;
        let height = 0;
        let running = false;
        let shapeCount = 0;
        
        const imageUpload = document.getElementById('imageUpload');
        const brushUpload = document.getElementById('brushUpload');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const shapeOpacityInput = document.getElementById('shapeOpacity');
        const candidatesInput = document.getElementById('candidates');
        const mutationsInput = document.getElementById('mutations');
        const maxShapesInput = document.getElementById('maxShapes');
        
        function loadImageFile(file, callback) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => callback(img);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        imageUpload.addEventListener('change', (e) => {
            loadImageFile(e.target.files[0], (img) => {
                targetImg = img;
                const canvas = document.getElementById('original');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                targetImageData = ctx.getImageData(0, 0, img.width, img.height);
                width = img.width;
                height = img.height;
            });
        });
        
        brushUpload.addEventListener('change', (e) => {
            loadImageFile(e.target.files[0], (img) => {
                brushImg = img;
            });
        });
        
        resetBtn.addEventListener('click', () => {
            running = false;
            shapeCount = 0;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            const canvas = document.getElementById('geometrized');
            canvas.width = 0;
            canvas.height = 0;
        });
        
        startBtn.addEventListener('click', () => {
            if (!targetImageData) {
                alert('Please upload a target image first.');
                return;
            }
            running = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            shapeCount = 0;
            const canvas = document.getElementById('geometrized');
            canvas.width = width;
            canvas.height = height;
            currentCtx = canvas.getContext('2d');
            // Set initial background
            const bgColor = getAverageColor(targetImageData);
            currentCtx.fillStyle = `rgb(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
            currentCtx.fillRect(0, 0, width, height);
            addShapeStep();
        });
        
        pauseBtn.addEventListener('click', () => {
            running = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
        });
        
        function getAverageColor(imageData) {
            let r = 0, g = 0, b = 0;
            const data = imageData.data;
            const len = data.length / 4;
            for (let i = 0; i < len; i++) {
                r += data[i * 4];
                g += data[i * 4 + 1];
                b += data[i * 4 + 2];
            }
            return {r: Math.floor(r / len), g: Math.floor(g / len), b: Math.floor(b / len)};
        }
        
        function addShapeStep() {
            if (!running || shapeCount >= parseInt(maxShapesInput.value)) {
                running = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                return;
            }
            
            const opacity = parseInt(shapeOpacityInput.value);
            const candidates = parseInt(candidatesInput.value);
            const mutations = parseInt(mutationsInput.value);
            
            let bestImprovement = 0;
            let bestColor = {r: 0, g: 0, b: 0};
            let bestParams = null;
            
            const currentImageData = currentCtx.getImageData(0, 0, width, height);
            
            for (let cand = 0; cand < candidates; cand++) {
                let params = generateRandomParams();
                let improvement = computeImprovement(params, currentImageData, opacity);
                for (let mut = 0; mut < mutations; mut++) {
                    const mutatedParams = mutateParams(params);
                    const mutImprovement = computeImprovement(mutatedParams, currentImageData, opacity);
                    if (mutImprovement > improvement) {
                        improvement = mutImprovement;
                        params = mutatedParams;
                    }
                }
                if (improvement > bestImprovement) {
                    bestImprovement = improvement;
                    bestParams = params;
                    bestColor = computeOptimalColor(params, currentImageData, opacity);
                }
            }
            
            if (bestImprovement > 0 && bestParams) {
                applyShape(bestParams, bestColor, opacity);
                shapeCount++;
            }
            
            requestAnimationFrame(addShapeStep);
        }
        
        function generateRandomParams() {
            const isBrush = !!brushImg;
            if (isBrush) {
                return {
                    type: 'brush',
                    x: Math.random() * width,
                    y: Math.random() * height,
                    scale: Math.random() * 0.15 + 0.05,
                    rotation: Math.random() * Math.PI * 2
                };
            } else {
                // Default to rectangle
                const x = Math.random() * width;
                const y = Math.random() * height;
                const w = (Math.random() * 0.2 + 0.05) * width;
                const h = (Math.random() * 0.2 + 0.05) * height;
                return {
                    type: 'rect',
                    x,
                    y,
                    w,
                    h
                };
            }
        }
        
        function mutateParams(params) {
            const mutated = {...params};
            const delta = 0.05; // Relative mutation
            mutated.x += (Math.random() - 0.5) * width * delta;
            mutated.y += (Math.random() - 0.5) * height * delta;
            mutated.x = Math.max(0, Math.min(width, mutated.x));
            mutated.y = Math.max(0, Math.min(height, mutated.y));
            if (params.type === 'brush') {
                mutated.scale += (Math.random() - 0.5) * mutated.scale * delta * 2;
                mutated.scale = Math.max(0.01, Math.min(1, mutated.scale));
                mutated.rotation += (Math.random() - 0.5) * Math.PI * delta * 4;
            } else if (params.type === 'rect') {
                mutated.w += (Math.random() - 0.5) * mutated.w * delta * 2;
                mutated.h += (Math.random() - 0.5) * mutated.h * delta * 2;
                mutated.w = Math.max(5, Math.min(width, mutated.w));
                mutated.h = Math.max(5, Math.min(height, mutated.h));
            }
            return mutated;
        }
        
        function computeImprovement(params, currentData, opacity) {
            const maskData = getMaskData(params, opacity);
            if (!maskData) return 0;
            const target = targetImageData.data;
            const current = currentData.data;
            let sumNumR = 0, sumNumG = 0, sumNumB = 0;
            let sumDen = 0;
            for (let i = 0; i < maskData.data.length; i += 4) {
                const maskAlpha = maskData.data[i + 3] / 255;
                if (maskAlpha > 0) {
                    sumNumR += (target[i] - current[i]) * maskAlpha;
                    sumNumG += (target[i + 1] - current[i + 1]) * maskAlpha;
                    sumNumB += (target[i + 2] - current[i + 2]) * maskAlpha;
                    sumDen += maskAlpha * maskAlpha;
                }
            }
            if (sumDen === 0) return 0;
            return (sumNumR * sumNumR + sumNumG * sumNumG + sumNumB * sumNumB) / sumDen;
        }
        
        function computeOptimalColor(params, currentData, opacity) {
            const maskData = getMaskData(params, opacity);
            if (!maskData) return {r: 0, g: 0, b: 0};
            const target = targetImageData.data;
            const current = currentData.data;
            let sumNumR = 0, sumNumG = 0, sumNumB = 0;
            let sumDen = 0;
            for (let i = 0; i < maskData.data.length; i += 4) {
                const maskAlpha = maskData.data[i + 3] / 255;
                if (maskAlpha > 0) {
                    sumNumR += (target[i] - current[i]) * maskAlpha;
                    sumNumG += (target[i + 1] - current[i + 1]) * maskAlpha;
                    sumNumB += (target[i + 2] - current[i + 2]) * maskAlpha;
                    sumDen += maskAlpha * maskAlpha;
                }
            }
            if (sumDen === 0) return {r: 0, g: 0, b: 0};
            return {
                r: Math.max(0, Math.min(255, Math.round(sumNumR / sumDen))),
                g: Math.max(0, Math.min(255, Math.round(sumNumG / sumDen))),
                b: Math.max(0, Math.min(255, Math.round(sumNumB / sumDen)))
            };
        }
        
        function getMaskData(params, opacity) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.clearRect(0, 0, width, height);
            
            if (params.type === 'brush' && brushImg) {
                tempCtx.save();
                tempCtx.translate(params.x, params.y);
                tempCtx.rotate(params.rotation);
                tempCtx.drawImage(brushImg, -brushImg.width * params.scale / 2, -brushImg.height * params.scale / 2, brushImg.width * params.scale, brushImg.height * params.scale);
                tempCtx.restore();
            } else if (params.type === 'rect') {
                tempCtx.fillStyle = `rgba(255, 255, 255, ${opacity / 255})`;
                tempCtx.fillRect(params.x, params.y, params.w, params.h);
            } else {
                return null;
            }
            return tempCtx.getImageData(0, 0, width, height);
        }
        
        function applyShape(params, color, opacity) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.clearRect(0, 0, width, height);
            
            if (params.type === 'brush' && brushImg) {
                tempCtx.save();
                tempCtx.translate(params.x, params.y);
                tempCtx.rotate(params.rotation);
                tempCtx.drawImage(brushImg, -brushImg.width * params.scale / 2, -brushImg.height * params.scale / 2, brushImg.width * params.scale, brushImg.height * params.scale);
                tempCtx.restore();
                tempCtx.globalCompositeOperation = 'source-in';
                tempCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                tempCtx.fillRect(0, 0, width, height);
            } else if (params.type === 'rect') {
                tempCtx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                tempCtx.globalAlpha = opacity / 255;
                tempCtx.fillRect(params.x, params.y, params.w, params.h);
            }
            
            currentCtx.drawImage(tempCanvas, 0, 0);
        }
    </script>
</body>
</html>