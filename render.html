<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cool Image Filter</title>
    <style>
        body { font-family: Arial, sans-serif; }
        canvas { border: 1px solid black; display: inline-block; }
        #controls { margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Image Geometrizer with Custom Brush and Multiple Shapes</h1>
    <p>cool paint filter.</p>
    
    <div id="controls">
        <label>Target Image: <input type="file" id="imageUpload" accept="image/*"></label><br>
        <label>Custom Brush (optional): <input type="file" id="brushUpload" accept="image/*"></label><br>
        <label>Shape Opacity (1-255): <input type="number" id="shapeOpacity" value="128" min="1" max="255"></label><br>
        <label>Candidates per Step: <input type="number" id="candidates" value="100" min="1" max="300"></label><br>
        <label>Mutations per Candidate: <input type="number" id="mutations" value="200" min="1" max="500"></label><br>
        <label>Max Shapes: <input type="number" id="maxShapes" value="10000" min="100" max="50000"></label><br>
        <div>Shape Types (select multiple for more detail):</div>
        <label><input type="checkbox" class="shapeType" value="rect" checked> Rectangles</label>
        <label><input type="checkbox" class="shapeType" value="rotated_rect"> Rotated Rectangles</label>
        <label><input type="checkbox" class="shapeType" value="triangle" checked> Triangles</label>
        <label><input type="checkbox" class="shapeType" value="ellipse" checked> Ellipses</label>
        <label><input type="checkbox" class="shapeType" value="rotated_ellipse"> Rotated Ellipses</label>
        <label><input type="checkbox" class="shapeType" value="circle"> Circles</label>
        <label><input type="checkbox" class="shapeType" value="line"> Lines</label>
        <label><input type="checkbox" class="shapeType" value="quadratic"> Quadratic Beziers</label>
        <label><input type="checkbox" class="shapeType" value="brush" id="brushCheckbox" disabled> Custom Brush (enabled if uploaded)</label><br>
        <button id="startBtn">Start</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resetBtn">Reset</button>
        <button id="saveBtn" disabled>Save as PNG</button>
        <div>Shapes Added: <span id="shapesAdded">0</span></div>
    </div>
    
    <canvas id="original" width="0" height="0"></canvas>
    <canvas id="geometrized" width="0" height="0"></canvas>
    
    <script>
        let targetImg = null;
        let targetImageData = null;
        let brushImg = null;
        let currentCtx = null;
        let width = 0;
        let height = 0;
        let running = false;
        let shapeCount = 0;
        let selectedShapes = ['rect'];
        
        const imageUpload = document.getElementById('imageUpload');
        const brushUpload = document.getElementById('brushUpload');
        const brushCheckbox = document.getElementById('brushCheckbox');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const saveBtn = document.getElementById('saveBtn');
        const shapeOpacityInput = document.getElementById('shapeOpacity');
        const candidatesInput = document.getElementById('candidates');
        const mutationsInput = document.getElementById('mutations');
        const maxShapesInput = document.getElementById('maxShapes');
        const shapesAddedSpan = document.getElementById('shapesAdded');
        const shapeTypeCheckboxes = document.querySelectorAll('.shapeType');
        
        function loadImageFile(file, callback) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => callback(img);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        imageUpload.addEventListener('change', (e) => {
            loadImageFile(e.target.files[0], (img) => {
                targetImg = img;
                const canvas = document.getElementById('original');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                targetImageData = ctx.getImageData(0, 0, img.width, img.height);
                width = img.width;
                height = img.height;
            });
        });
        
        brushUpload.addEventListener('change', (e) => {
            loadImageFile(e.target.files[0], (img) => {
                brushImg = img;
                brushCheckbox.disabled = false;
                brushCheckbox.checked = true;
            });
        });
        
        resetBtn.addEventListener('click', () => {
            running = false;
            shapeCount = 0;
            shapesAddedSpan.textContent = 0;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            saveBtn.disabled = true;
            const canvas = document.getElementById('geometrized');
            canvas.width = 0;
            canvas.height = 0;
        });
        
        startBtn.addEventListener('click', () => {
            if (!targetImageData) {
                alert('Please upload a target image first.');
                return;
            }
            selectedShapes = Array.from(shapeTypeCheckboxes)
                .filter(cb => cb.checked && (cb.value !== 'brush' || brushImg))
                .map(cb => cb.value);
            if (selectedShapes.length === 0) {
                alert('Please select at least one shape type.');
                return;
            }
            running = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
            saveBtn.disabled = true;
            shapeCount = 0;
            shapesAddedSpan.textContent = 0;
            const canvas = document.getElementById('geometrized');
            canvas.width = width;
            canvas.height = height;
            currentCtx = canvas.getContext('2d');
            const bgColor = getAverageColor(targetImageData);
            currentCtx.fillStyle = `rgb(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
            currentCtx.fillRect(0, 0, width, height);
            addShapeStep();
        });
        
        pauseBtn.addEventListener('click', () => {
            running = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            saveBtn.disabled = false;
        });
        
        saveBtn.addEventListener('click', () => {
            const canvas = document.getElementById('geometrized');
            const link = document.createElement('a');
            link.download = 'geometrized.png';
            link.href = canvas.toDataURL();
            link.click();
        });
        
        function getAverageColor(imageData) {
            let r = 0, g = 0, b = 0;
            const data = imageData.data;
            const len = data.length / 4;
            for (let i = 0; i < len; i++) {
                r += data[i * 4];
                g += data[i * 4 + 1];
                b += data[i * 4 + 2];
            }
            return {r: Math.floor(r / len), g: Math.floor(g / len), b: Math.floor(b / len)};
        }
        
        function addShapeStep() {
            if (!running || shapeCount >= parseInt(maxShapesInput.value)) {
                running = false;
                startBtn.disabled = false;
                pauseBtn.disabled = true;
                saveBtn.disabled = false;
                return;
            }
            
            const opacity = parseInt(shapeOpacityInput.value);
            const candidates = parseInt(candidatesInput.value);
            const mutations = parseInt(mutationsInput.value);
            
            let bestImprovement = 0;
            let bestColor = {r: 0, g: 0, b: 0};
            let bestParams = null;
            
            const currentImageData = currentCtx.getImageData(0, 0, width, height);
            
            for (let cand = 0; cand < candidates; cand++) {
                let params = generateRandomParams();
                let improvement = computeImprovement(params, currentImageData, opacity);
                for (let mut = 0; mut < mutations; mut++) {
                    const mutatedParams = mutateParams(params);
                    const mutImprovement = computeImprovement(mutatedParams, currentImageData, opacity);
                    if (mutImprovement > improvement) {
                        improvement = mutImprovement;
                        params = mutatedParams;
                    }
                }
                if (improvement > bestImprovement) {
                    bestImprovement = improvement;
                    bestParams = params;
                    bestColor = computeOptimalColor(params, currentImageData, opacity);
                }
            }
            
            if (bestImprovement > 0 && bestParams) {
                applyShape(bestParams, bestColor, opacity);
                shapeCount++;
                shapesAddedSpan.textContent = shapeCount;
            }
            
            requestAnimationFrame(addShapeStep);
        }
        
        function generateRandomParams() {
            const type = selectedShapes[Math.floor(Math.random() * selectedShapes.length)];
            const params = { type };
            const progress = shapeCount / parseInt(maxShapesInput.value);
            const currentMaxSizeRel = 0.5 * (1 - progress) + 0.01;
            const maxRadius = Math.min(width, height) * currentMaxSizeRel / 2;
            const minSize = 3;
            
            const centerX = Math.random() * width;
            const centerY = Math.random() * height;
            
            function randomPoint() {
                let x = centerX + (Math.random() - 0.5) * 2 * maxRadius;
                let y = centerY + (Math.random() - 0.5) * 2 * maxRadius;
                x = Math.max(0, Math.min(width, x));
                y = Math.max(0, Math.min(height, y));
                return [x, y];
            }
            
            switch (type) {
                case 'brush':
                    if (!brushImg) return generateRandomParams();
                    params.x = Math.random() * width;
                    params.y = Math.random() * height;
                    params.scale = Math.random() * currentMaxSizeRel + 0.01;
                    params.rotation = Math.random() * Math.PI * 2;
                    break;
                case 'rect':
                case 'rotated_rect':
                    [params.x, params.y] = randomPoint();
                    params.w = minSize + Math.random() * (maxRadius * 2);
                    params.h = minSize + Math.random() * (maxRadius * 2);
                    if (type === 'rotated_rect') params.rotation = Math.random() * Math.PI * 2;
                    break;
                case 'triangle':
                    params.points = [];
                    for (let i = 0; i < 3; i++) {
                        const [x, y] = randomPoint();
                        params.points.push(x, y);
                    }
                    break;
                case 'ellipse':
                case 'rotated_ellipse':
                    [params.x, params.y] = randomPoint();
                    params.rx = minSize / 2 + Math.random() * maxRadius;
                    params.ry = minSize / 2 + Math.random() * maxRadius;
                    if (type === 'rotated_ellipse') params.rotation = Math.random() * Math.PI * 2;
                    break;
                case 'circle':
                    [params.x, params.y] = randomPoint();
                    params.r = minSize / 2 + Math.random() * maxRadius;
                    break;
                case 'line':
                    params.points = [];
                    for (let i = 0; i < 2; i++) {
                        const [x, y] = randomPoint();
                        params.points.push(x, y);
                    }
                    params.lineWidth = 1 + Math.random() * (20 * (1 - progress));
                    break;
                case 'quadratic':
                    params.points = [];
                    for (let i = 0; i < 3; i++) {
                        const [x, y] = randomPoint();
                        params.points.push(x, y);
                    }
                    params.lineWidth = 1 + Math.random() * (20 * (1 - progress));
                    break;
            }
            return params;
        }
        
        function mutateParams(params) {
            const mutated = { ...params, points: params.points ? [...params.points] : undefined };
            const delta = 0.1;
            
            const mutatePos = (val, max) => val + (Math.random() - 0.5) * max * delta;
            
            if ('x' in mutated) mutated.x = Math.max(0, Math.min(width, mutatePos(mutated.x, width)));
            if ('y' in mutated) mutated.y = Math.max(0, Math.min(height, mutatePos(mutated.y, height)));
            if ('w' in mutated) mutated.w = Math.max(3, Math.min(width, mutated.w + (Math.random() - 0.5) * mutated.w * delta * 2));
            if ('h' in mutated) mutated.h = Math.max(3, Math.min(height, mutated.h + (Math.random() - 0.5) * mutated.h * delta * 2));
            if ('rx' in mutated) mutated.rx = Math.max(1.5, Math.min(width / 2, mutated.rx + (Math.random() - 0.5) * mutated.rx * delta * 2));
            if ('ry' in mutated) mutated.ry = Math.max(1.5, Math.min(height / 2, mutated.ry + (Math.random() - 0.5) * mutated.ry * delta * 2));
            if ('r' in mutated) mutated.r = Math.max(1.5, Math.min(Math.min(width, height) / 2, mutated.r + (Math.random() - 0.5) * mutated.r * delta * 2));
            if ('rotation' in mutated) mutated.rotation += (Math.random() - 0.5) * Math.PI * delta * 4;
            if ('scale' in mutated) mutated.scale = Math.max(0.01, Math.min(1, mutated.scale + (Math.random() - 0.5) * mutated.scale * delta * 2));
            if ('lineWidth' in mutated) mutated.lineWidth = Math.max(1, mutated.lineWidth + (Math.random() - 0.5) * mutated.lineWidth * delta * 2);
            if (mutated.points) {
                for (let i = 0; i < mutated.points.length; i += 2) {
                    mutated.points[i] = Math.max(0, Math.min(width, mutatePos(mutated.points[i], width)));
                    mutated.points[i + 1] = Math.max(0, Math.min(height, mutatePos(mutated.points[i + 1], height)));
                }
            }
            return mutated;
        }
        
        function computeImprovement(params, currentData, opacity) {
            const maskData = getMaskData(params, opacity);
            if (!maskData) return 0;
            const target = targetImageData.data;
            const current = currentData.data;
            let sumNumR = 0, sumNumG = 0, sumNumB = 0;
            let sumDen = 0;
            for (let i = 0; i < maskData.data.length; i += 4) {
                const maskAlpha = maskData.data[i + 3] / 255;
                if (maskAlpha > 0) {
                    sumNumR += (target[i] - current[i]) * maskAlpha;
                    sumNumG += (target[i + 1] - current[i + 1]) * maskAlpha;
                    sumNumB += (target[i + 2] - current[i + 2]) * maskAlpha;
                    sumDen += maskAlpha * maskAlpha;
                }
            }
            if (sumDen === 0) return 0;
            return (sumNumR * sumNumR + sumNumG * sumNumG + sumNumB * sumNumB) / sumDen;
        }
        
        function computeOptimalColor(params, currentData, opacity) {
            const maskData = getMaskData(params, opacity);
            if (!maskData) return {r: 0, g: 0, b: 0};
            const target = targetImageData.data;
            const current = currentData.data;
            let sumNumR = 0, sumNumG = 0, sumNumB = 0;
            let sumDen = 0;
            for (let i = 0; i < maskData.data.length; i += 4) {
                const maskAlpha = maskData.data[i + 3] / 255;
                if (maskAlpha > 0) {
                    sumNumR += (target[i] - current[i]) * maskAlpha;
                    sumNumG += (target[i + 1] - current[i + 1]) * maskAlpha;
                    sumNumB += (target[i + 2] - current[i + 2]) * maskAlpha;
                    sumDen += maskAlpha * maskAlpha;
                }
            }
            if (sumDen === 0) return {r: 0, g: 0, b: 0};
            return {
                r: Math.max(0, Math.min(255, Math.round(sumNumR / sumDen))),
                g: Math.max(0, Math.min(255, Math.round(sumNumG / sumDen))),
                b: Math.max(0, Math.min(255, Math.round(sumNumB / sumDen)))
            };
        }
        
        function getMaskData(params, opacity) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.clearRect(0, 0, width, height);
            tempCtx.globalAlpha = opacity / 255;
            drawShape(tempCtx, params, 'white', true);
            return tempCtx.getImageData(0, 0, width, height);
        }
        
        function applyShape(params, color, opacity) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.clearRect(0, 0, width, height);
            tempCtx.globalAlpha = 1; // Solid on temp
            drawShape(tempCtx, params, `rgb(${color.r}, ${color.g}, ${color.b})`, false);
            currentCtx.globalAlpha = opacity / 255;
            currentCtx.drawImage(tempCanvas, 0, 0);
            currentCtx.globalAlpha = 1;
        }
        
        function drawShape(ctx, params, colorStyle, isMask) {
            ctx.beginPath();
            if (params.type === 'brush' && brushImg) {
                ctx.save();
                ctx.translate(params.x, params.y);
                ctx.rotate(params.rotation);
                ctx.drawImage(brushImg, -brushImg.width * params.scale / 2, -brushImg.height * params.scale / 2, brushImg.width * params.scale, brushImg.height * params.scale);
                ctx.restore();
                ctx.globalCompositeOperation = 'source-in';
                ctx.fillStyle = colorStyle;
                ctx.fillRect(0, 0, width, height);
                ctx.globalCompositeOperation = 'source-over';
            } else if (['line', 'quadratic'].includes(params.type)) {
                ctx.strokeStyle = colorStyle;
                ctx.lineWidth = params.lineWidth;
                ctx.lineCap = 'round';
                if (params.type === 'line') {
                    ctx.moveTo(params.points[0], params.points[1]);
                    ctx.lineTo(params.points[2], params.points[3]);
                } else { // quadratic
                    ctx.moveTo(params.points[0], params.points[1]);
                    ctx.quadraticCurveTo(params.points[2], params.points[3], params.points[4], params.points[5]);
                }
                ctx.stroke();
            } else {
                ctx.fillStyle = colorStyle;
                switch (params.type) {
                    case 'rect':
                        ctx.rect(params.x, params.y, params.w, params.h);
                        break;
                    case 'rotated_rect':
                        ctx.save();
                        ctx.translate(params.x + params.w / 2, params.y + params.h / 2);
                        ctx.rotate(params.rotation);
                        ctx.rect(-params.w / 2, -params.h / 2, params.w, params.h);
                        ctx.restore();
                        break;
                    case 'triangle':
                        ctx.moveTo(params.points[0], params.points[1]);
                        ctx.lineTo(params.points[2], params.points[3]);
                        ctx.lineTo(params.points[4], params.points[5]);
                        ctx.closePath();
                        break;
                    case 'ellipse':
                        ctx.ellipse(params.x, params.y, params.rx, params.ry, 0, 0, Math.PI * 2);
                        break;
                    case 'rotated_ellipse':
                        ctx.save();
                        ctx.translate(params.x, params.y);
                        ctx.rotate(params.rotation);
                        ctx.ellipse(0, 0, params.rx, params.ry, 0, 0, Math.PI * 2);
                        ctx.restore();
                        break;
                    case 'circle':
                        ctx.arc(params.x, params.y, params.r, 0, Math.PI * 2);
                        break;
                }
                ctx.fill();
            }
        }
    </script>
</body>
</html>